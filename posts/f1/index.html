<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="zh-cn">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>如何理解 F1 的 schema change | Mini How</title>



<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="http://blog.minifish.org/posts/f1/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="http://blog.minifish.org/">
          <h1 id="nav-heading" class="title is-4">Mini How</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"></nav>
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
    </div>
    <h2 class="subtitle is-6">December 25, 2017</h2>
    <h1 class="title">如何理解 F1 的 schema change</h1>
    
    <div class="content">
      <h1 id="背景">背景</h1>
<p>F1 的 DDL 论文是 TiDB 的 DDL 实现的基础，F1 的论文主体有两篇，一篇总体介绍 F1 的 DDL ，另一篇专门介绍 DDL 的 schema change 方法。个人认为，第二篇才是关键，也是我看的比较糊涂的。
这里有一篇对于其<a href="http://www.ifi.uzh.ch/dbtg/teaching/courses/SDBS/Papaioannou.pdf">第二篇论文的介绍</a>，贴在这里有助于理解。</p>
<h1 id="理解">理解</h1>
<h2 id="在线-ddl-概念">在线 DDL 概念</h2>
<p>这里讲的 DDL 都是指的在线的 DDL 。在线 DDL 的概念来自于 MySQL ，PostgreSQL 之类的数据库应该是不支持的。这一概念也非常的模糊，区分就在于在做 DDL 的时候是不是要加排他锁，来阻塞住事务。所以，所有的数据库都可以做在线 DDL ，就看是否愿意花力气去做了。对于传统业务，由于不是那么强调 7*24 也就可以挑个夜深人静，甚至就是维护的时间去做 DDL ，就算有几个用户在使用服务，大不了他们稍卡一下。而现代互联网对维护时间卡得很严，也就对这种不阻塞的 DDL 有更高的需求，最最互联网式的数据库 MySQL 就率先支持了这类操作。实现方式大多是采用复制一份新的 schema 的表，然后，期间对表的操作同时发到新旧两个表上去。</p>
<p>MySQL 支持的在线 DDL 可以看<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-create-index-overview.html">这个网页</a>。基本就是两类，对索引的操作和对列的操作。这里解答了我的一个疑惑，为什么 TiDB 里实现的解释总是拿添加索引来举例？</p>
<h2 id="f1-的方法">F1 的方法</h2>
<p>以之前做类似 Aurora 的经验，这一块问题非常多，如果只做离线的 DDL 大可不必这么麻烦。按照 F1 的论文，它通过</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">                                    (reorganization)
absent -&gt; delete only -&gt; write only ---------------&gt; public
</code></pre></div><p>这样一系列状态变化来完成一个 DDL ，其中的约定是，每个节点都通过这四个状态，节点通过接受命令来进入下一状态。每个状态在所有节点里出现的时间最长不超过两个租约时间，怎么保证呢？通过下面这个规则，如果节点接收到上个状态转换的命令后太长时间没收到下个命令，也就是某个状态超过了两个租约时间，意味着自己接受指令太迟了，该节点就拒绝提供服务挂掉。</p>
<p>这四个状态里，absent 相当于节点还没收到指令的状态，public 相当于 DDL 做完的状态，那中间的两个状态呢？背景介绍里的链接给出了如下解释：</p>
<blockquote>
<ul>
<li>A delete-only table or column can be modified only by delete operations.</li>
<li>A delete-only index, can be modified only by delete and update operations. Update operations can delete key-value pairs corresponding to updated index keys, but they cannot create any new ones.</li>
<li>A write-only column or index can have their key-value pairs modified by insert, delete, and update operations, but none of their pairs can be read by user transactions.</li>
<li>A write-only constraint is applied for all new insert, delete, and update operations, but it is not guaranteed to hold over all existing data.</li>
</ul>
</blockquote>
<p>整理成表格后：</p>
<table>
<thead>
<tr>
<th>delete only</th>
<th>write only</th>
</tr>
</thead>
<tbody>
<tr>
<td>表、列只能删，索引能更新（其实表不算）</td>
<td>列和索引既能删也能更新也能插入</td>
</tr>
</tbody>
</table>
<p>第一个状态就非常奇葩，第二个更是奇葩，直接叫 can not read 多好。
据说这样设计的原因是为了让同时存在的两个状态能行为一致，也就是（ absent 和 delete only ），（ delete only 和 write only ），（ write only 和 public ）。</p>
<p>举例：</p>
<p>给表 t 添加索引 idx ，部署环境是同时有两台数据库 a 和 b 。</p>
<ol>
<li>a 进入 delete only ，添加完索引。b 还没接到任何消息。
<ul>
<li>有对 a b 的插入操作，a 的 idx 忽略，b 没有感知也忽略。</li>
<li>读操作，a b idx 都忽略。</li>
<li>删除和更新，a idx 响应，b 忽略。</li>
</ul>
</li>
<li>a 进入 write only ，b 进入 delete only ，添加完索引。
<ul>
<li>有对 a b 的插入操作，a 的 idx 响应，b 忽略。（ b 丢失了索引数据？）</li>
<li>读操作，a b idx 都忽略。</li>
<li>删除和更新，a b idx 都响应。</li>
</ul>
</li>
<li>a 进入 public 状态，b 进入 write only 状态。
<ul>
<li>有对 a b 的插入操作，a b 的 idx 都响应。</li>
<li>读操作，a idx 响应 b 忽略。</li>
<li>删除和更新，a b idx 都响应。</li>
</ul>
</li>
</ol>
<p>给表 t 删除索引 idx ，部署环境也是有两台数据库 a 和 b 。</p>
<ol>
<li>a 进入 delete only ，删除完索引。b 还没接到任何消息。
<ul>
<li>有对 a b 的插入操作，a 的 idx 忽略，b 有索引 idx ，插入索引。</li>
<li>读操作，a idx 忽略，b 使用索引 idx 。</li>
<li>删除和更新，a idx 响应，b 也响应。（ a 的索引已经没了，所以响应也是空操作？）</li>
</ul>
</li>
<li>a 进入 write only ，b 进入 delete only ，添加完索引。
<ul>
<li>有对 a b 的插入操作，a 的 idx 响应，b 忽略。（ a 空操作？）</li>
<li>读操作，a b idx 都忽略。</li>
<li>删除和更新，a b idx 都响应。（索引事实上已经删掉了，找不到索引数据，空操作？）</li>
</ul>
</li>
<li>a 进入 public 状态，b 进入 write only 状态。
<ul>
<li>有对 a b 的插入操作，a b 的 idx 都响应。（ a 已经没有这个索引了，b 空操作？）</li>
<li>读操作，a idx 响应 b 忽略。</li>
<li>删除和更新，a b idx 都响应。（ b 空操作？）</li>
</ul>
</li>
</ol>

      
    </div>
    
  </div>
</section>


<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
  
    <script type="text/javascript">
      var disqus_shortname = 'jackysp';
      function disqus() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }
  
      disqus();
  

    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p></p>
    
  </div>
</section>



</body>
</html>

